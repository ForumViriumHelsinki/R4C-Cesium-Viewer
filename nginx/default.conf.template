proxy_cache_path /tmp/nginx_cache levels=1:2 keys_zone=global_cache:10m max_size=10g inactive=60m use_temp_path=off;
proxy_cache_path /tmp/nginx_wms_cache levels=1:2 keys_zone=wms_cache:20m max_size=20g inactive=7d use_temp_path=off;

server {
    listen 80;
    server_name _;
    root /usr/share/nginx/html;
    index index.html;

    # DNS resolver for service discovery
    # Uses NGINX_DNS_RESOLVER env var, defaults to 127.0.0.11 (Docker's embedded DNS)
    # For Kubernetes: set to kube-dns ClusterIP (e.g., 10.96.0.10 or check your cluster)
    # For Docker Compose: leave default (127.0.0.11)
    resolver ${NGINX_DNS_RESOLVER} valid=30s ipv6=off;

    # ===========================================
    # Health Check Endpoints
    # ===========================================

    # Liveness probe - always returns 200 if nginx is running
    location = /livez {
        access_log off;
        add_header Content-Type application/json;
        return 200 '{"status":"ok","timestamp":"$time_iso8601"}';
    }

    # Simple health check - returns 200 if nginx can serve requests
    location = /healthz {
        access_log off;
        add_header Content-Type application/json;
        return 200 '{"status":"healthy","server":"r4c-frontend","timestamp":"$time_iso8601"}';
    }

    # Readiness probe - checks if PyGeoAPI is reachable
    location = /readyz {
        access_log off;
        add_header Content-Type application/json;

        # Store the host in a variable
        set $pygeoapi_host "${VITE_PYGEOAPI_HOST}";
        set $pygeoapi_protocol "https";
        if ($pygeoapi_host ~* "^localhost:[0-9]+$") {
            set $pygeoapi_protocol "http";
        }
        if ($pygeoapi_host ~* "\.svc\.cluster\.local$") {
            set $pygeoapi_protocol "http";
        }
        if ($pygeoapi_host ~* "^[^.]+$") {
            set $pygeoapi_protocol "http";
        }

        # Proxy to PyGeoAPI collections endpoint to verify backend is ready
        proxy_pass $pygeoapi_protocol://$pygeoapi_host/collections?limit=1;
        proxy_connect_timeout 5s;
        proxy_read_timeout 5s;
        proxy_intercept_errors on;
        error_page 500 502 503 504 = @readyz_error;
    }

    location @readyz_error {
        add_header Content-Type application/json;
        return 503 '{"status":"unhealthy","server":"r4c-frontend","error":"pygeoapi_unreachable","timestamp":"$time_iso8601"}';
    }

    # Status overview - lists all available health check endpoints
    location = /status {
        access_log off;
        add_header Content-Type application/json;

        # Check if digitransit key is configured (nginx variable logic)
        set $digitransit_configured "false";
        set $digitransit_key_check "${VITE_DIGITRANSIT_KEY}";
        if ($digitransit_key_check != "") {
            set $digitransit_configured "true";
        }

        return 200 '{"status":"healthy","server":"r4c-frontend","nginx_version":"$nginx_version","timestamp":"$time_iso8601","config":{"pygeoapi":"${VITE_PYGEOAPI_HOST}","digitransit_key_set":$digitransit_configured},"checks":["/status/pygeoapi","/status/hsy-wms","/status/stat-fi","/status/digitransit","/status/helsinki-wms"]}';
    }

    # -------------------------------------------
    # Individual Service Health Checks
    # These verify external service connectivity
    # and can catch auth/config errors
    # -------------------------------------------

    # Check PyGeoAPI - returns collections list if healthy
    location = /status/pygeoapi {
        access_log off;
        set $pygeoapi_host "${VITE_PYGEOAPI_HOST}";
        set $pygeoapi_protocol "https";
        if ($pygeoapi_host ~* "^localhost:[0-9]+$") {
            set $pygeoapi_protocol "http";
        }
        if ($pygeoapi_host ~* "\.svc\.cluster\.local$") {
            set $pygeoapi_protocol "http";
        }
        if ($pygeoapi_host ~* "^[^.]+$") {
            set $pygeoapi_protocol "http";
        }

        proxy_pass $pygeoapi_protocol://$pygeoapi_host/collections?limit=1;
        proxy_connect_timeout 5s;
        proxy_read_timeout 10s;
        proxy_intercept_errors on;
        error_page 401 403 = @status_auth_error;
        error_page 500 502 503 504 = @status_service_error;
    }

    # Check HSY WMS - GetCapabilities request
    location = /status/hsy-wms {
        access_log off;
        proxy_pass https://kartta.hsy.fi/geoserver/wms?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities;
        proxy_connect_timeout 5s;
        proxy_read_timeout 10s;
        proxy_intercept_errors on;
        error_page 401 403 = @status_auth_error;
        error_page 500 502 503 504 = @status_service_error;
    }

    # Check Statistics Finland WFS
    location = /status/stat-fi {
        access_log off;
        proxy_pass https://geo.stat.fi/geoserver/postialue/wfs?SERVICE=WFS&VERSION=2.0.0&REQUEST=GetCapabilities;
        proxy_connect_timeout 5s;
        proxy_read_timeout 10s;
        proxy_intercept_errors on;
        error_page 401 403 = @status_auth_error;
        error_page 500 502 503 504 = @status_service_error;
    }

    # Check Digitransit API - requires API key, catches auth errors
    location = /status/digitransit {
        access_log off;
        set $digitransit_key "${VITE_DIGITRANSIT_KEY}";
        proxy_set_header digitransit-subscription-key $digitransit_key;
        # Simple geocoding request to verify API key works
        proxy_pass https://api.digitransit.fi/geocoding/v1/search?text=helsinki&size=1;
        proxy_connect_timeout 5s;
        proxy_read_timeout 10s;
        proxy_intercept_errors on;
        error_page 401 403 = @status_auth_error;
        error_page 500 502 503 504 = @status_service_error;
    }

    # Check Helsinki WMS
    location = /status/helsinki-wms {
        access_log off;
        proxy_pass https://kartta.hel.fi/ws/geoserver/avoindata/ows?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities;
        proxy_connect_timeout 5s;
        proxy_read_timeout 10s;
        proxy_intercept_errors on;
        error_page 401 403 = @status_auth_error;
        error_page 500 502 503 504 = @status_service_error;
    }

    # Error handlers for service checks
    location @status_auth_error {
        add_header Content-Type application/json;
        return 503 '{"status":"unhealthy","error":"auth_error","message":"Authentication or authorization failed - check API keys and credentials","timestamp":"$time_iso8601"}';
    }

    location @status_service_error {
        add_header Content-Type application/json;
        return 503 '{"status":"unhealthy","error":"service_error","message":"Service unavailable or returned error","timestamp":"$time_iso8601"}';
    }

    # ===========================================
    # End Health Check Endpoints
    # ===========================================

    # Global proxy settings
    proxy_cache global_cache;
    proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;
    proxy_cache_valid 200 60m;
    proxy_cache_key $request_uri;
    proxy_ssl_verify off;
    add_header X-Cache-Status $upstream_cache_status;

    # Security headers
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    # Global streaming settings
    proxy_http_version 1.1;
    proxy_set_header Connection "";
    chunked_transfer_encoding on;

    # Default buffer settings
    proxy_buffering on;  # Keep buffering on by default
    proxy_buffer_size 8k;
    proxy_buffers 8 8k;

    # Optimize for tile serving
    proxy_busy_buffers_size 24k;
    proxy_temp_file_write_size 24k;

    # Common proxy headers
    proxy_set_header Host $proxy_host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;

    # Enable gzip compression for static assets
    gzip on;
    gzip_vary on;
    gzip_min_length 1000;
    gzip_proxied any;
    gzip_types text/plain text/css text/xml text/javascript application/javascript application/json application/xml+rss application/x-javascript;
    gzip_disable "MSIE [1-6]\.";

    # Rule 1: NEVER cache index.html (always check for new version)
    location = /index.html {
        add_header Cache-Control "no-cache, no-store, must-revalidate" always;
        add_header Pragma "no-cache" always;
        add_header Expires "0" always;
        try_files $uri =404;
    }

    # Rule 2: Aggressively cache hashed assets (they're immutable)
    location /assets/ {
        add_header Cache-Control "public, max-age=31536000, immutable" always;
        expires 1y;
        access_log off;
        try_files $uri =404;
    }

    # Rule 3: Don't cache unhashed static assets
    location ~* \.(svg|png|jpg|jpeg|gif|ico|webp)$ {
        add_header Cache-Control "no-cache" always;
        try_files $uri =404;
    }

    # Rule 4: Default fallback for SPA routing
    location / {
        add_header Cache-Control "no-cache, no-store, must-revalidate" always;
        add_header Pragma "no-cache" always;
        add_header Expires "0" always;
        try_files $uri $uri/ /index.html;
    }

    # GO Feature Flag relay proxy (OFREP endpoint)
    location /feature-flags/ {
        set $goff_host "gofeatureflag.feature-flags.svc.cluster.local";
        proxy_pass http://$goff_host:1031/;
        proxy_set_header Host $goff_host;
        proxy_connect_timeout 3s;
        proxy_read_timeout 5s;
        proxy_cache off;
        add_header Cache-Control "no-cache, no-store" always;
    }

    # FIXED: Updated to match Vite configuration (removed _2024 suffix)
    location /paavo {
        proxy_pass https://geo.stat.fi;
        rewrite ^/paavo(.*)$ /geoserver/postialue/wfs?service=WFS&request=GetFeature&typename=postialue:pno_tilasto&version=2.0.0&outputFormat=application/json&CQL_FILTER=kunta%20IN%20(%27091%27%2C%27092%27%2C%27049%27%2C%27235%27)&srsName=EPSG:4326$1 break;
    }

    location /pygeoapi/ {
        # Store the host in a variable first
        set $pygeoapi_host "${VITE_PYGEOAPI_HOST}";

        # Derive protocol based on host type:
        # - Use http for localhost development (localhost:port)
        # - Use http for internal Kubernetes services (short names without dots, or *.svc.cluster.local)
        # - Use https for external services (pygeoapi.dataportal.fi, etc.)
        set $pygeoapi_protocol "https";
        if ($pygeoapi_host ~* "^localhost:[0-9]+$") {
            set $pygeoapi_protocol "http";
        }
        if ($pygeoapi_host ~* "\.svc\.cluster\.local$") {
            set $pygeoapi_protocol "http";
        }
        # Short K8s service names (no dots) are internal services using HTTP
        if ($pygeoapi_host ~* "^[^.]+$") {
            set $pygeoapi_protocol "http";
        }

        # Rewrite must come BEFORE proxy_pass when using variables
        # Strip /pygeoapi prefix: /pygeoapi/collections/foo -> /collections/foo
        rewrite ^/pygeoapi/(.*)$ /$1 break;

        # proxy_pass without trailing slash preserves the rewritten path
        proxy_pass $pygeoapi_protocol://$pygeoapi_host;
        proxy_set_header Host $pygeoapi_host;
    }

    location /wms/proxy {
        proxy_pass https://kartta.hsy.fi;
        proxy_cache_key $request_uri;

        # Use WMS-specific cache
        proxy_cache wms_cache;
        proxy_cache_valid 200 7d;        # Cache successful responses for 7 days
        proxy_cache_valid 404 60m;       # Cache not-found for 1 hour
        proxy_cache_use_stale error timeout http_500 http_502 http_503 http_504;
        proxy_cache_background_update on;
        proxy_cache_lock on;

        # Optimize for tile delivery
        proxy_buffers 8 256k;
        proxy_buffer_size 256k;
        proxy_busy_buffers_size 256k;
        proxy_temp_file_write_size 256k;

        # Increase timeouts for large tiles
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;

        # Enable compression
        gzip on;
        gzip_types image/jpeg image/png image/gif;
        rewrite ^/wms/proxy(.*)$ /geoserver/wms$1 break;
    }

    # Helsinki city WMS (kartta.hel.fi)
    location /helsinki-wms {
        proxy_pass https://kartta.hel.fi;
        proxy_cache_key $request_uri;

        # Use WMS-specific cache
        proxy_cache wms_cache;
        proxy_cache_valid 200 7d;        # Cache successful responses for 7 days
        proxy_cache_valid 404 60m;       # Cache not-found for 1 hour
        proxy_cache_use_stale error timeout http_500 http_502 http_503 http_504;
        proxy_cache_background_update on;
        proxy_cache_lock on;

        # Optimize for tile delivery
        proxy_buffers 8 256k;
        proxy_buffer_size 256k;
        proxy_busy_buffers_size 256k;
        proxy_temp_file_write_size 256k;

        # Increase timeouts for large tiles
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;

        # Enable compression
        gzip on;
        gzip_types image/jpeg image/png image/gif;
        rewrite ^/helsinki-wms(.*)$ /ws/geoserver/avoindata/ows$1 break;
    }

    # ADDED: Missing NDVI proxy route
    location /ndvi_public {
        proxy_pass https://storage.googleapis.com;
        rewrite ^/ndvi_public(.*)$ /ndvi_public$1 break;
    }

    location /terrain-proxy {
        proxy_pass https://kartta.hel.fi;
        rewrite ^/terrain-proxy(.*)$ /3d/datasource-data/4383570b-33a3-4a9f-ae16-93373aff5ffa$1 break;
    }

    location /wms/layers {
        proxy_pass https://kartta.hsy.fi;
        rewrite ^/wms/layers$ /geoserver/wms?request=getCapabilities break;
    }

    # HSY action API proxy (for GetHierarchicalMapLayerGroups, etc.)
    location /hsy-action {
        proxy_pass https://kartta.hsy.fi;

        # Explicit SSL and header settings for external API
        proxy_ssl_server_name on;
        proxy_set_header Host kartta.hsy.fi;
        proxy_set_header Accept application/json;

        # Cache API responses
        proxy_cache global_cache;
        proxy_cache_valid 200 1h;
        proxy_cache_valid 404 5m;

        rewrite ^/hsy-action(.*)$ /action$1 break;
    }

    # FIXED: Environment variable handling for digitransit
    location /digitransit {
        # Use nginx environment variable substitution
        set $digitransit_key "${VITE_DIGITRANSIT_KEY}";
        proxy_set_header digitransit-subscription-key $digitransit_key;

        proxy_pass https://api.digitransit.fi;
        rewrite ^/digitransit(.*)$ $1 break;
    }
}
