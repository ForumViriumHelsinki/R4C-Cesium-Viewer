#!/usr/bin/env node

/**
 * Performance Regression Check Script
 *
 * Analyzes the performance report generated by the Playwright performance reporter
 * and determines if there are any critical performance regressions.
 *
 * Exit codes:
 * 0 - No regressions or only minor warnings
 * 1 - Critical regressions detected (>30% slower)
 * 2 - Error reading or parsing reports
 */

const fs = require('fs');
const path = require('path');

// Import thresholds from shared config
// Note: Using require for CommonJS compatibility
const configPath = path.join(process.cwd(), 'tests/performance-config.ts');
let CRITICAL_THRESHOLD = 30; // Default fallback
let WARNING_THRESHOLD = 20; // Default fallback

// Try to read config from TypeScript file (simple parsing)
try {
	const configContent = fs.readFileSync(configPath, 'utf-8');
	const criticalMatch = configContent.match(/CRITICAL_THRESHOLD_PERCENT:\s*(\d+)/);
	const warningMatch = configContent.match(/WARNING_THRESHOLD_PERCENT:\s*(\d+)/);

	if (criticalMatch) CRITICAL_THRESHOLD = parseInt(criticalMatch[1]);
	if (warningMatch) WARNING_THRESHOLD = parseInt(warningMatch[1]);
} catch (error) {
	console.warn('‚ö†Ô∏è  Could not load config from performance-config.ts, using defaults');
}

function main() {
	const reportFile = path.join(process.cwd(), 'test-results/performance-report.json');

	// Check if report exists
	if (!fs.existsSync(reportFile)) {
		console.error('‚ùå Performance report not found at:', reportFile);
		console.error('Make sure to run tests with the performance reporter first.');
		process.exit(2);
	}

	let report;
	try {
		const content = fs.readFileSync(reportFile, 'utf-8');
		report = JSON.parse(content);
	} catch (error) {
		console.error('‚ùå Failed to parse performance report:', error.message);
		process.exit(2);
	}

	console.log('\n' + '='.repeat(80));
	console.log('PERFORMANCE REGRESSION CHECK');
	console.log('='.repeat(80));

	console.log(`\nReport timestamp: ${report.timestamp}`);
	console.log(`Total tests: ${report.summary.totalTests}`);
	console.log(`Average duration: ${report.summary.avgDuration}ms`);

	// Add null check for slowestTest
	if (report.summary.slowestTest && report.summary.slowestTest.name) {
		console.log(
			`Slowest test: ${report.summary.slowestTest.name} (${report.summary.slowestTest.duration}ms)`
		);
	}

	// Analyze regressions
	const criticalRegressions = report.regressions.filter(
		(r) => r.percentIncrease >= CRITICAL_THRESHOLD
	);
	const warnings = report.regressions.filter(
		(r) => r.percentIncrease >= WARNING_THRESHOLD && r.percentIncrease < CRITICAL_THRESHOLD
	);

	if (report.regressions.length === 0) {
		console.log('\n‚úÖ No performance regressions detected!');
		console.log('All tests are performing within acceptable limits.');

		// Generate GitHub Actions summary if in CI (moved from bottom to run after main logic)
		generateGitHubSummary(report);

		process.exit(0);
	}

	// Display warnings
	if (warnings.length > 0) {
		console.log('\n' + '‚ö†Ô∏è  '.repeat(40));
		console.log('PERFORMANCE WARNINGS');
		console.log('-'.repeat(80));

		for (const warning of warnings) {
			console.log(`\nüü° ${warning.suite} > ${warning.test}`);
			console.log(`   Baseline: ${Math.round(warning.baseline)}ms`);
			console.log(`   Actual: ${Math.round(warning.actual)}ms`);
			console.log(`   Regression: +${Math.round(warning.percentIncrease)}% slower`);
		}
	}

	// Display critical regressions
	if (criticalRegressions.length > 0) {
		console.log('\n' + 'üî¥ '.repeat(40));
		console.log('CRITICAL PERFORMANCE REGRESSIONS');
		console.log('-'.repeat(80));

		for (const regression of criticalRegressions) {
			console.log(`\nüî¥ ${regression.suite} > ${regression.test}`);
			console.log(`   Baseline: ${Math.round(regression.baseline)}ms`);
			console.log(`   Actual: ${Math.round(regression.actual)}ms`);
			console.log(`   Regression: +${Math.round(regression.percentIncrease)}% slower`);
		}

		console.log('\n' + '='.repeat(80));
		console.error(
			`\n‚ùå FAILED: ${criticalRegressions.length} critical performance regression(s) detected!`
		);
		console.error(`These tests are more than ${CRITICAL_THRESHOLD}% slower than baseline.`);
		console.error('Please investigate and optimize before merging.');
		console.log('\n');

		// Generate GitHub Actions summary if in CI (moved from bottom to run after main logic)
		generateGitHubSummary(report);

		process.exit(1);
	}

	// Only warnings, no critical issues
	console.log('\n' + '='.repeat(80));
	console.log(
		`\n‚ö†Ô∏è  ${warnings.length} performance warning(s) detected (${WARNING_THRESHOLD}-${CRITICAL_THRESHOLD}% slower).`
	);
	console.log('These are not blocking, but consider investigating if feasible.');
	console.log('\n');

	// Generate GitHub Actions summary if in CI (moved from bottom to run after main logic)
	generateGitHubSummary(report);

	process.exit(0);
}

// Generate markdown summary for GitHub Actions
function generateMarkdownSummary(report) {
	const criticalRegressions = report.regressions.filter(
		(r) => r.percentIncrease >= CRITICAL_THRESHOLD
	);
	const warnings = report.regressions.filter(
		(r) => r.percentIncrease >= WARNING_THRESHOLD && r.percentIncrease < CRITICAL_THRESHOLD
	);

	let markdown = '## Performance Report\n\n';
	markdown += `**Report timestamp:** ${report.timestamp}\n\n`;
	markdown += '### Summary\n\n';
	markdown += `- **Total tests:** ${report.summary.totalTests}\n`;
	markdown += `- **Average duration:** ${report.summary.avgDuration}ms\n`;

	// Add null check for slowestTest
	if (report.summary.slowestTest && report.summary.slowestTest.name) {
		markdown += `- **Slowest test:** ${report.summary.slowestTest.name} (${report.summary.slowestTest.duration}ms)\n`;
	}

	markdown += `- **Timeouts:** ${report.summary.timeouts}\n\n`;

	if (criticalRegressions.length > 0) {
		markdown += '### üî¥ Critical Regressions\n\n';
		markdown += '| Suite | Test | Baseline | Actual | Regression |\n';
		markdown += '|-------|------|----------|--------|------------|\n';

		for (const reg of criticalRegressions) {
			markdown += `| ${reg.suite} | ${reg.test} | ${Math.round(reg.baseline)}ms | ${Math.round(reg.actual)}ms | +${Math.round(reg.percentIncrease)}% |\n`;
		}
		markdown += '\n';
	}

	if (warnings.length > 0) {
		markdown += '### ‚ö†Ô∏è  Warnings\n\n';
		markdown += '| Suite | Test | Baseline | Actual | Regression |\n';
		markdown += '|-------|------|----------|--------|------------|\n';

		for (const warning of warnings) {
			markdown += `| ${warning.suite} | ${warning.test} | ${Math.round(warning.baseline)}ms | ${Math.round(warning.actual)}ms | +${Math.round(warning.percentIncrease)}% |\n`;
		}
		markdown += '\n';
	}

	if (report.regressions.length === 0) {
		markdown += '### ‚úÖ No Performance Regressions\n\n';
		markdown += 'All tests are performing within acceptable limits.\n\n';
	}

	markdown += '### Suite Performance\n\n';
	markdown += '| Suite | Duration | Tests |\n';
	markdown += '|-------|----------|-------|\n';

	for (const suite of report.suites) {
		markdown += `| ${suite.name} | ${Math.round(suite.duration / 1000)}s | ${suite.testCount} |\n`;
	}

	return markdown;
}

// Generate GitHub Actions summary if in CI
// This is now called from within main() to ensure it runs after the report is analyzed
function generateGitHubSummary(report) {
	if (process.env.GITHUB_STEP_SUMMARY) {
		try {
			const markdown = generateMarkdownSummary(report);
			fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, markdown);
			console.log('‚úÖ GitHub Actions summary generated');
		} catch (error) {
			console.warn('‚ö†Ô∏è  Failed to generate GitHub Actions summary:', error.message);
		}
	}
}

main();
