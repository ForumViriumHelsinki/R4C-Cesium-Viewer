<template>
  <div
v-if="isVisible"
id="bar-chart-container"
>
    <div
id="close-btn"
@click="toggleChartVisibility(false)"
>
X
</div>
  </div>
</template>

<script setup>
import { onMounted, onBeforeUnmount, ref } from 'vue';
import * as d3 from 'd3';
import * as Cesium from 'cesium';
import Plot from '../services/plot.js';
import { eventBus } from '../services/eventEmitter.js';
import { usePropsStore } from '../stores/propsStore.js';

// Pinia store
const propsStore = usePropsStore();

const margin = { top: 20, right: 20, bottom: 80, left: 30 };
const width = 500 - margin.left - margin.right;
const height = 200 - margin.top - margin.bottom;

const isVisible = ref( false ); // Initialize as false

const toggleChartVisibility = async ( value ) => {
	isVisible.value = value; // Set the visibility based on the parameter
};
// Define color schemes
const heatColors = [
	{ color: '#ffffcc', range: '< 0.2' },
	{ color: '#ffeda0', range: '0.2 - 0.4' },
	{ color: '#feb24c', range: '0.4 - 0.6' },
	{ color: '#f03b20', range: '0.6 - 0.8' },
	{ color: '#bd0026', range: '> 0.8' },
];

const floodColors = [
	{ color: '#c6dbef', range: '< 0.2' },  // More saturated light blue
	{ color: '#9ecae1', range: '0.2 - 0.4' },  // Slightly darker blue
	{ color: '#6baed6', range: '0.4 - 0.6' },  // Mid-tone blue
	{ color: '#3182bd', range: '0.6 - 0.8' },  // Darker blue
	{ color: '#08519c', range: '> 0.8' },  // Deep blue
];

// Define green space vulnerability colors with reversed logic
const greenSpaceColors = [
	{ color: '#006d2c', range: '< 0.2' },           // Darkest green for < 0.2
	{ color: '#31a354', range: '0.2 - 0.4' },       // Dark green for 0.2 - 0.4
	{ color: '#74c476', range: '0.4 - 0.6' },       // Medium green for 0.4 - 0.6
	{ color: '#a1d99b', range: '0.6 - 0.8' },       // Light green for 0.6 - 0.8
	{ color: '#e5f5e0', range: '> 0.8' },           // Very light green for > 0.8
];

// Define a mapping of indices to their corresponding color schemes
const indexToColorScheme = {
	heat_index: heatColors,
	flood_index: floodColors,
	sensitivity: heatColors, // Sensitivity uses heat coloring
	flood_exposure: greenSpaceColors,
	flood_prepare: floodColors,
	flood_respond: floodColors,
	flood_recover: floodColors,
	heat_exposure: heatColors,
	heat_prepare: heatColors,
	heat_respond: heatColors,
	age: heatColors, // Age uses heat coloring
	income: heatColors, // Income uses heat coloring
	info: heatColors, // Info uses heat coloring
	tenure: heatColors, // Tenure uses heat coloring
	green: greenSpaceColors, // Green areas use heat coloring
	social_networks: floodColors, // Social networks use flood coloring
	overcrowding: floodColors, // Overcrowding uses flood coloring
};

const getColorForIndex = ( indexValue, indexType ) => {
	const colorScheme = indexToColorScheme[indexType] || heatColors; // Default to heat colors
	if ( indexValue < 0.2 ) return Cesium.Color.fromCssColorString( colorScheme[0].color ).withAlpha( 0.8 );
	if ( indexValue < 0.4 ) return Cesium.Color.fromCssColorString( colorScheme[1].color ).withAlpha( 0.8 );
	if ( indexValue < 0.6 ) return Cesium.Color.fromCssColorString( colorScheme[2].color ).withAlpha( 0.8 );
	if ( indexValue < 0.8 ) return Cesium.Color.fromCssColorString( colorScheme[3].color ).withAlpha( 0.8 );
	return Cesium.Color.fromCssColorString( colorScheme[4].color ).withAlpha( 0.8 );
};

// Adjusted getColorForIndexValue function to use getColorForIndex
const getColorForIndexValue = ( index, value ) => {
	if ( index === 'avgheatexposure' ) {
		// Custom color scheme for avgheatexposure
		const red = 1; // Red component is fixed at 1
		const green = 1 - value; // Green decreases as avgheatexposure increases
		const blue = 0; // Blue component is fixed at 0
		const alpha = value; // Alpha (opacity) is the avgheatexposure value

		return `rgba(${red * 255}, ${green * 255}, ${blue * 255}, ${alpha})`;
	}

	// Use the new color scheme for other indices
	const color = getColorForIndex( value, index );
	return `rgba(${color.red * 255}, ${color.green * 255}, ${color.blue * 255}, ${color.alpha})`;
};

const renderChart = ( data ) => {
	const containerId = 'bar-chart-container';
	const plotService = new Plot();
	// Filter data to only include values between 0 and 1 (inclusive)
	const filteredData = data.filter( d => d.value >= 0 && d.value <= 1 );

	// Prepare the data for the chart with index modification
	const chartData = filteredData.map( d => ( {
		index: d.index === 'avgheatexposure' ? 'surface temp' : d.index,
		value: d.value,
		color: d.color || 'steelblue' // Default color if not specified
	} ) );

	// Create SVG element
	const svg = plotService.createSVGElement( margin, width, height, `#${containerId}` );

	// Create scales
	const xScale = plotService.createScaleBand(
		chartData.map( d => d.index ),
		width
	);
	const yScale = plotService.createScaleLinear( 0, d3.max( chartData, d => d.value ), [ height, 0 ] );

	// Setup axes
	const xAxis = d3.axisBottom( xScale );
	const yAxis = d3.axisLeft( yScale );

	// Create y-axis
	svg.append( 'g' )
		.call( yAxis );

	// Create x-axis
	const xAxisGroup = svg.append( 'g' )
		.attr( 'transform', `translate(0, ${height})` )
		.call( xAxis );

	// Rotate x-axis labels to vertical
	xAxisGroup.selectAll( 'text' )
		.attr( 'transform', 'rotate(-90)' )
		.attr( 'y', 0 ) // Adjust as needed
		.attr( 'x', -5 ) // Move the labels right under the x-axis; adjust this value
		.style( 'text-anchor', 'end' ); // Align the text to the end of the label

	// Create tooltip
	const tooltip = plotService.createTooltip( `#${containerId}` );

	// Create the bars
	createBars( svg, chartData, xScale, yScale, height, tooltip, 0, 'steelblue' );

	// Add chart title
	plotService.addTitle( svg, 'Vulnerability Indices', width, margin );
};

// Refactor the createBars method
const createBars = ( svg, data, xScale, yScale, height, tooltip, xOffset, barColor ) => {
	const barWidth = xScale.bandwidth();

	const bars = svg.selectAll( '.bar' )
		.data( data )
		.enter()
		.append( 'g' )
		.attr( 'class', 'bar' )
		.attr( 'transform', d => `translate(${xScale( d.index ) + xOffset}, 0)` );

	bars.append( 'rect' )
		.attr( 'x', 0 )
		.attr( 'y', d => yScale( d.value ) )
		.attr( 'width', barWidth )
		.attr( 'height', d => height - yScale( d.value ) )
		.attr( 'fill', d => d.color || barColor ) // Use specified color or default
		.on( 'mouseover', ( event, d ) => {
			const containerRect = document.getElementById( 'bar-chart-container' ).getBoundingClientRect();
			const xPos = event.pageX - containerRect.left;
			const yPos = event.pageY - containerRect.top;
			const dataFormatter = ( data ) => `${data.index}: ${( data.value ).toFixed( 2 )}`;

			tooltip.transition().duration( 200 ).style( 'opacity', 0.9 );
			tooltip.html( dataFormatter( d ) )
				.style( 'left', `${xPos}px` )
				.style( 'top', `${yPos}px` );
		} )
		.on( 'mouseout', () => {
			tooltip.transition().duration( 200 ).style( 'opacity', 0 );
		} );
};

const prepareData = ( newEntity ) => {

	const propertiesToInclude = [
		'heat_index', 'flood_index', 'sensitivity', 'flood_exposure',
		'flood_prepare', 'flood_respond', 'flood_recover', 'heat_exposure',
		'heat_prepare', 'heat_respond', 'age', 'income', 'info', 'tenure',
		'green', 'social_networks', 'overcrowding', 'avgheatexposure'
	];

	const data = propertiesToInclude
		.map( property => {
			const value = newEntity[property]?.getValue();
			if ( value !== undefined ) {
				return {
					index: property,
					value: value,
					color: getColorForIndexValue( property, value )
				};
			}
			return null;
		} )
		.filter( item => item !== null );

	renderChart( data );
  
};

const handleEvent = async ( ) => {
  
	await toggleChartVisibility( false );
	const newEntity = propsStore.heatFloodVulnerabilityEntity;
	newEntity && ( await toggleChartVisibility( true ), prepareData( newEntity ) ); 

};

onMounted( () => {
	// Show chart when new data is rendered
	eventBus.on( 'createHeatFloodVulnerabilityChart', handleEvent );
} );

onBeforeUnmount( () => {
	eventBus.off( 'createHeatFloodVulnerabilityChart', handleEvent );
	d3.select( '#bar-chart-container' ).select( 'svg' ).remove(); // Clean up on unmount
} );
</script>

<style scoped>
#bar-chart-container {
  position: fixed;
  bottom: 20px;
  right: 10px;
  width: 500px;
  height: 200px; 
  font-size: smaller;
  border: 1px solid black;
  box-shadow: 3px 5px 5px black; 
  background-color: white;
  z-index: 100000;
}

#close-btn {
  position: absolute;
  top: 0;
  right: 5px;
  cursor: pointer;
  font-weight: bold;
  color: red;
}
</style>
>