<template>
	<div
		v-if="isVisible"
		id="bar-chart-container"
		class="vulnerability-chart"
	>
		<div class="chart-header">
			<div class="chart-title">
				<span class="chart-icon">ðŸ“Š</span>
				<span>Vulnerability Analysis</span>
			</div>
			<button
				class="close-btn"
				aria-label="Close chart"
				@click="toggleChartVisibility(false)"
			>
				<span class="close-icon">âœ•</span>
			</button>
		</div>
		<div
			id="chart-svg-container"
			class="chart-content"
		/>
	</div>
</template>

<script setup>
import { onMounted, onBeforeUnmount, ref } from 'vue';
import * as d3 from 'd3';
import Plot from '../services/plot.js';
import { eventBus } from '../services/eventEmitter.js';
import { usePropsStore } from '../stores/propsStore.js';

// Pinia store
const propsStore = usePropsStore();

const margin = { top: 20, right: 20, bottom: 80, left: 30 };
const width = 500 - margin.left - margin.right;
const height = 200 - margin.top - margin.bottom;

const isVisible = ref(false); // Initialize as false

const toggleChartVisibility = async (value) => {
	isVisible.value = value; // Set the visibility based on the parameter
};
// Define color schemes
const heatColors = [
	{ color: '#ffffcc', range: '< 0.2' },
	{ color: '#ffeda0', range: '0.2 - 0.4' },
	{ color: '#feb24c', range: '0.4 - 0.6' },
	{ color: '#f03b20', range: '0.6 - 0.8' },
	{ color: '#bd0026', range: '> 0.8' },
];

const floodColors = [
	{ color: '#c6dbef', range: '< 0.2' }, // More saturated light blue
	{ color: '#9ecae1', range: '0.2 - 0.4' }, // Slightly darker blue
	{ color: '#6baed6', range: '0.4 - 0.6' }, // Mid-tone blue
	{ color: '#3182bd', range: '0.6 - 0.8' }, // Darker blue
	{ color: '#08519c', range: '> 0.8' }, // Deep blue
];

// Define green space vulnerability colors with reversed logic
const greenSpaceColors = [
	{ color: '#006d2c', range: '< 0.2' }, // Darkest green for < 0.2
	{ color: '#31a354', range: '0.2 - 0.4' }, // Dark green for 0.2 - 0.4
	{ color: '#74c476', range: '0.4 - 0.6' }, // Medium green for 0.4 - 0.6
	{ color: '#a1d99b', range: '0.6 - 0.8' }, // Light green for 0.6 - 0.8
	{ color: '#e5f5e0', range: '> 0.8' }, // Very light green for > 0.8
];

// Define a mapping of indices to their corresponding color schemes
const indexToColorScheme = {
	heat_index: heatColors,
	flood_index: floodColors,
	sensitivity: heatColors, // Sensitivity uses heat coloring
	flood_exposure: greenSpaceColors,
	flood_prepare: floodColors,
	flood_respond: floodColors,
	flood_recover: floodColors,
	heat_exposure: heatColors,
	heat_prepare: heatColors,
	heat_respond: heatColors,
	age: heatColors, // Age uses heat coloring
	income: heatColors, // Income uses heat coloring
	info: heatColors, // Info uses heat coloring
	tenure: heatColors, // Tenure uses heat coloring
	green: greenSpaceColors, // Green areas use heat coloring
	social_networks: floodColors, // Social networks use flood coloring
	overcrowding: floodColors, // Overcrowding uses flood coloring
};

const getColorForIndex = (indexValue, indexType) => {
	const colorScheme = indexToColorScheme[indexType] || heatColors; // Default to heat colors
	if (indexValue < 0.2) return colorScheme[0].color;
	if (indexValue < 0.4) return colorScheme[1].color;
	if (indexValue < 0.6) return colorScheme[2].color;
	if (indexValue < 0.8) return colorScheme[3].color;
	return colorScheme[4].color;
};

// Adjusted getColorForIndexValue function to use getColorForIndex
const getColorForIndexValue = (index, value) => {
	if (index === 'avgheatexposure') {
		// Custom color scheme for avgheatexposure
		const red = 1; // Red component is fixed at 1
		const green = 1 - value; // Green decreases as avgheatexposure increases
		const blue = 0; // Blue component is fixed at 0
		const alpha = value; // Alpha (opacity) is the avgheatexposure value

		return `rgba(${red * 255}, ${green * 255}, ${blue * 255}, ${alpha})`;
	}

	// Use the new color scheme for other indices
	const color = getColorForIndex(value, index);
	return `rgba(${color.red * 255}, ${color.green * 255}, ${color.blue * 255}, ${color.alpha})`;
};

const renderChart = (data) => {
	const containerId = 'chart-svg-container';
	const plotService = new Plot();
	// Filter data to only include values between 0 and 1 (inclusive)
	const filteredData = data.filter((d) => d.value >= 0 && d.value <= 1);

	// Prepare the data for the chart with index modification
	const chartData = filteredData.map((d) => ({
		index: d.index === 'avgheatexposure' ? 'surface temp' : d.index,
		value: d.value,
		color: d.color || 'steelblue', // Default color if not specified
	}));

	// Create SVG element
	const svg = plotService.createSVGElement(margin, width, height, `#${containerId}`);

	// Create scales
	const xScale = plotService.createScaleBand(
		chartData.map((d) => d.index),
		width
	);
	const yScale = plotService.createScaleLinear(
		0,
		d3.max(chartData, (d) => d.value),
		[height, 0]
	);

	// Setup axes
	const xAxis = d3.axisBottom(xScale);
	const yAxis = d3.axisLeft(yScale);

	// Create y-axis
	svg.append('g').call(yAxis);

	// Create x-axis
	const xAxisGroup = svg.append('g').attr('transform', `translate(0, ${height})`).call(xAxis);

	// Rotate x-axis labels to vertical
	xAxisGroup
		.selectAll('text')
		.attr('transform', 'rotate(-90)')
		.attr('y', 0) // Adjust as needed
		.attr('x', -5) // Move the labels right under the x-axis; adjust this value
		.style('text-anchor', 'end'); // Align the text to the end of the label

	// Create tooltip
	const tooltip = plotService.createTooltip(`#${containerId}`);

	// Create the bars
	createBars(svg, chartData, xScale, yScale, height, tooltip, 0, 'steelblue');

	// Add chart title
	plotService.addTitle(svg, 'Vulnerability Indices', width, margin);
};

// Refactor the createBars method
const createBars = (svg, data, xScale, yScale, height, tooltip, xOffset, barColor) => {
	const barWidth = xScale.bandwidth();

	const bars = svg
		.selectAll('.bar')
		.data(data)
		.enter()
		.append('g')
		.attr('class', 'bar')
		.attr('transform', (d) => `translate(${xScale(d.index) + xOffset}, 0)`);

	bars
		.append('rect')
		.attr('x', 0)
		.attr('y', (d) => yScale(d.value))
		.attr('width', barWidth)
		.attr('height', (d) => height - yScale(d.value))
		.attr('fill', (d) => d.color || barColor) // Use specified color or default
		.on('mouseover', (event, d) => {
			const containerRect = document.getElementById('bar-chart-container').getBoundingClientRect();
			const xPos = event.pageX - containerRect.left;
			const yPos = event.pageY - containerRect.top;
			const dataFormatter = (data) => `${data.index}: ${data.value.toFixed(2)}`;

			tooltip.transition().duration(200).style('opacity', 0.9);
			tooltip.html(dataFormatter(d)).style('left', `${xPos}px`).style('top', `${yPos}px`);
		})
		.on('mouseout', () => {
			tooltip.transition().duration(200).style('opacity', 0);
		});
};

const prepareData = (newEntity) => {
	const propertiesToInclude = [
		'heat_index',
		'flood_index',
		'sensitivity',
		'flood_exposure',
		'flood_prepare',
		'flood_respond',
		'flood_recover',
		'heat_exposure',
		'heat_prepare',
		'heat_respond',
		'age',
		'income',
		'info',
		'tenure',
		'green',
		'social_networks',
		'overcrowding',
		'avgheatexposure',
	];

	const data = propertiesToInclude
		.map((property) => {
			const value = newEntity[property]?.getValue();
			if (value !== undefined) {
				return {
					index: property,
					value: value,
					color: getColorForIndexValue(property, value),
				};
			}
			return null;
		})
		.filter((item) => item !== null);

	renderChart(data);
};

const handleEvent = async () => {
	await toggleChartVisibility(false);
	const newEntity = propsStore.heatFloodVulnerabilityEntity;
	if (newEntity) {
		await toggleChartVisibility(true);
		prepareData(newEntity);
	}
};

onMounted(() => {
	// Show chart when new data is rendered
	eventBus.on('createHeatFloodVulnerabilityChart', handleEvent);
});

onBeforeUnmount(() => {
	eventBus.off('createHeatFloodVulnerabilityChart', handleEvent);
	d3.select('#chart-svg-container').select('svg').remove(); // Clean up on unmount
});
</script>

<style scoped>
.vulnerability-chart {
	position: fixed;
	bottom: 24px;
	right: 24px;
	width: 420px;
	max-height: 300px;
	font-size: 13px;
	background: rgba(255, 255, 255, 0.95);
	backdrop-filter: blur(12px);
	border-radius: 12px;
	box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
	border: 1px solid rgba(0, 0, 0, 0.1);
	z-index: 100000;
	font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
	overflow: hidden;
}

.chart-header {
	display: flex;
	align-items: center;
	justify-content: space-between;
	padding: 12px 16px;
	background: rgba(0, 0, 0, 0.02);
	border-bottom: 1px solid rgba(0, 0, 0, 0.08);
}

.chart-title {
	display: flex;
	align-items: center;
	gap: 8px;
	font-weight: 600;
	color: #2c3e50;
	font-size: 14px;
}

.chart-icon {
	font-size: 16px;
}

.close-btn {
	display: flex;
	align-items: center;
	justify-content: center;
	width: 24px;
	height: 24px;
	border: none;
	background: rgba(239, 68, 68, 0.1);
	color: #ef4444;
	border-radius: 6px;
	cursor: pointer;
	transition: all 0.2s ease;
	padding: 0;
}

.close-btn:hover {
	background: rgba(239, 68, 68, 0.2);
	transform: scale(1.05);
}

.close-icon {
	font-size: 12px;
	font-weight: 600;
}

.chart-content {
	padding: 16px;
	min-height: 180px;
}

/* Mobile responsiveness */
@media (max-width: 768px) {
	.vulnerability-chart {
		position: fixed;
		bottom: 16px;
		right: 16px;
		left: 16px;
		width: auto;
		max-width: none;
	}

	.chart-title {
		font-size: 13px;
	}

	.chart-content {
		padding: 12px;
		min-height: 160px;
	}
}

/* High contrast mode */
@media (prefers-contrast: high) {
	.vulnerability-chart {
		background: #ffffff;
		border: 2px solid #000000;
	}

	.close-btn {
		background: #ef4444;
		color: #ffffff;
	}
}
</style>
